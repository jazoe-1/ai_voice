import os
import json
import numpy as np
import logging
from typing import Dict, List, Any, Optional, Tuple
from PIL import Image
from OpenGL.GL import *
from OpenGL.GL import shaders
from PyQt5.QtGui import QImage
from .parameter import ParameterManager
from ..utils.math_utils import create_transform_matrix

logger = logging.getLogger(__name__)


class Texture:
    """OpenGL纹理"""

    def __init__(self, texture_id: int, width: int, height: int):
        self.id = texture_id
        self.width = width
        self.height = height


class TextureManager:
    """纹理管理器"""

    def __init__(self):
        self.textures = {}  # 纹理缓存
        self.quality = "high"  # 纹理质量: high, medium, low

    def set_quality(self, quality: str):
        """设置纹理质量"""
        if quality in ["high", "medium", "low"] and quality != self.quality:
            self.quality = quality
            self.clear_cache()

    def clear_cache(self):
        """清除纹理缓存"""
        for texture_id in self.textures.values():
            glDeleteTextures(1, [texture_id.id])
        self.textures.clear()

    def load_texture(self, path: str, force_reload: bool = False) -> Optional[Texture]:
        """加载纹理

        Args:
            path: 纹理文件路径
            force_reload: 是否强制重新加载

        Returns:
            Texture对象或None（如果加载失败）
        """
        cache_key = f"{path}_{self.quality}"

        # 检查缓存
        if not force_reload and cache_key in self.textures:
            return self.textures[cache_key]

        # 根据质量设置缩放因子
        scale = 1.0
        if self.quality == "medium":
            scale = 0.75
        elif self.quality == "low":
            scale = 0.5

        try:
            # 使用PIL加载图像
            image = Image.open(path).convert("RGBA")
            if scale < 1.0:
                new_width = int(image.width * scale)
                new_height = int(image.height * scale)
                image = image.resize((new_width, new_height), Image.LANCZOS)

            # 获取像素数据
            img_data = np.array(image.getdata(), np.uint8).reshape(image.height, image.width, 4)

            # 创建OpenGL纹理
            texture_id = glGenTextures(1)
            glBindTexture(GL_TEXTURE_2D, texture_id)

            # 设置纹理参数
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)

            # 上传纹理数据
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.width, image.height,
                         0, GL_RGBA, GL_UNSIGNED_BYTE, img_data)

            # 创建Texture对象
            texture = Texture(texture_id, image.width, image.height)

            # 缓存并返回
            self.textures[cache_key] = texture
            return texture

        except Exception as e:
            logger.error(f"Error loading texture {path}: {e}")
            return None


class Renderer:
    """OpenGL渲染器"""

    def __init__(self, parameter_manager: ParameterManager):
        self.parameter_manager = parameter_manager
        self.texture_manager = TextureManager()
        self.parts = {}  # 存储模型部件
        self.initialized = False
        self.shader_program = None
        self.vao = None
        self.vbo = None
        self.ebo = None

    def initialize(self):
        """初始化OpenGL渲染器"""
        try:
            # 设置OpenGL版本和配置
            glClearColor(0.0, 0.0, 0.0, 0.0)  # 透明背景
            
            # 启用混合
            glEnable(GL_BLEND)
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            
            # 创建着色器程序
            self.create_shader_program()
            
            # 创建顶点缓冲区
            self.create_vertex_buffer()
            
            # 初始化标志
            self.initialized = True
            logger.info("OpenGL渲染器初始化成功")
            
        except Exception as e:
            logger.error(f"OpenGL渲染器初始化失败: {e}")
            self.initialized = False
            # 显示更详细的错误信息
            self.show_opengl_error(str(e))

    def show_opengl_error(self, error_message):
        """显示OpenGL错误信息"""
        from PyQt5.QtWidgets import QMessageBox
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Critical)
        msg.setWindowTitle("OpenGL渲染错误")
        msg.setText("OpenGL渲染器初始化失败")
        msg.setInformativeText(f"错误信息: {error_message}")
        
        # 获取OpenGL版本信息
        try:
            vendor = glGetString(GL_VENDOR).decode('utf-8')
            renderer = glGetString(GL_RENDERER).decode('utf-8')
            version = glGetString(GL_VERSION).decode('utf-8')
            
            detailed_text = f"OpenGL详细信息:\n" \
                            f"供应商: {vendor}\n" \
                            f"渲染器: {renderer}\n" \
                            f"版本: {version}\n\n" \
                            f"请确保您的系统支持OpenGL 3.3或更高版本，并安装了最新的显卡驱动程序。"
            
            msg.setDetailedText(detailed_text)
        except:
            msg.setDetailedText("无法获取OpenGL信息。请确保您的系统支持OpenGL 3.3或更高版本。")
        
        msg.exec_()

    def compile_shaders(self):
        """编译顶点和片元着色器"""
        # 简化的顶点着色器
        vertex_shader_source = """
        #version 330 core
        layout (location = 0) in vec3 position;
        layout (location = 1) in vec2 inTexCoord;
        
        out vec2 texCoord;
        
        uniform mat4 transform;
        
        void main()
        {
            gl_Position = vec4(position.x, position.y, 0.0, 1.0);
            texCoord = inTexCoord;
        }
        """

        # 简化的片元着色器
        fragment_shader_source = """
        #version 330 core
        in vec2 texCoord;
        
        out vec4 FragColor;
        
        uniform sampler2D textureSampler;
        
        void main()
        {
            FragColor = texture(textureSampler, texCoord);
        }
        """

        # 编译着色器
        try:
            vertex_shader = shaders.compileShader(vertex_shader_source, GL_VERTEX_SHADER)
            fragment_shader = shaders.compileShader(fragment_shader_source, GL_FRAGMENT_SHADER)
            self.shader_program = shaders.compileProgram(vertex_shader, fragment_shader)
            
            # 获取uniform位置
            self.transform_loc = glGetUniformLocation(self.shader_program, "transform")
            self.texture_loc = glGetUniformLocation(self.shader_program, "textureSampler")
            
            logging.info("着色器编译成功")
        except Exception as e:
            logging.error(f"Error compiling shaders: {e}")
            raise

    def create_buffers(self):
        """创建顶点缓冲对象"""
        self.vao = glGenVertexArrays(1)
        self.vbo = glGenBuffers(1)
        self.ebo = glGenBuffers(1)
        
        # 绑定VAO
        glBindVertexArray(self.vao)
        
        # 创建并绑定VBO
        glBindBuffer(GL_ARRAY_BUFFER, self.vbo)
        
        # 创建并绑定EBO
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.ebo)
        
        # 设置顶点属性指针
        # 位置属性
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * 4, ctypes.c_void_p(0))
        glEnableVertexAttribArray(0)
        
        # 纹理坐标属性
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * 4, ctypes.c_void_p(3 * 4))
        glEnableVertexAttribArray(1)
        
        # 解绑VAO
        glBindVertexArray(0)

    def load_model(self, model_data: Dict):
        """加载模型数据
        
        Args:
            model_data: 解析后的模型数据
        """
        self.parts = {}
        
        # 加载所有部件
        parts_data = model_data.get("Parts", [])
        for part_data in parts_data:
            part_id = part_data.get("Id", "")
            if not part_id:
                continue
                
            # 创建部件对象
            part = {
                "id": part_id,
                "name": part_data.get("Name", ""),
                "opacity": 1.0,
                "visible": True,
                "texture_path": part_data.get("TexturePath", ""),
                "mesh": self.create_mesh_for_part(part_data),
                "deformers": part_data.get("Deformers", []),
                "depth": part_data.get("Depth", 0)
            }
            
            # 加载纹理
            if part["texture_path"]:
                texture = self.texture_manager.load_texture(part["texture_path"])
                if texture:
                    part["texture"] = texture
            
            self.parts[part_id] = part

    def create_mesh_for_part(self, part_data: Dict) -> Dict:
        """为部件创建网格数据
        
        Args:
            part_data: 部件数据
            
        Returns:
            网格数据字典
        """
        # 这里简化处理，为每个部件创建一个矩形网格
        # 实际应用中应该从模型文件中读取顶点数据
        
        # 默认的矩形顶点（包含位置和纹理坐标）
        vertices = np.array([
            # 位置(x,y,z)      # 纹理坐标(u,v)
            -0.5, -0.5, 0.0,    0.0, 1.0,
             0.5, -0.5, 0.0,    1.0, 1.0,
             0.5,  0.5, 0.0,    1.0, 0.0,
            -0.5,  0.5, 0.0,    0.0, 0.0
        ], dtype=np.float32)
        
        # 索引
        indices = np.array([
            0, 1, 2,
            2, 3, 0
        ], dtype=np.uint32)
        
        return {
            "vertices": vertices,
            "indices": indices,
            "vertex_count": 4,
            "index_count": 6
        }

    def render(self):
        """渲染当前模型"""
        if not self.initialized:
            logging.warning("渲染器未初始化")
            return
            
        if not self.parts:
            logging.warning("没有模型部件可渲染")
            return
            
        # 清除缓冲区
        glClear(GL_COLOR_BUFFER_BIT)
        
        # 使用着色器程序
        glUseProgram(self.shader_program)
        
        # 激活纹理单元
        glActiveTexture(GL_TEXTURE0)
        glUniform1i(self.texture_loc, 0)
        
        # 按深度排序部件
        sorted_parts = sorted(self.parts.values(), key=lambda p: p.get("depth", 0))
        
        # 渲染每个部件
        for part in sorted_parts:
            if not part.get("visible", True):
                continue
                
            # 获取部件参数
            alpha = part.get("opacity", 1.0)
            
            # 应用参数影响
            for deformer in part.get("deformers", []):
                param_name = deformer.get("parameter", "")
                if param_name:
                    param_value = self.parameter_manager.get_parameter(param_name, 0.0)
                    
                    # 根据变形器类型应用变换
                    deformer_type = deformer.get("type", "")
                    if deformer_type == "opacity":
                        alpha *= (1.0 + param_value * deformer.get("scale", 0.0))
            
            # 限制alpha值在有效范围内
            alpha = max(0.0, min(1.0, alpha))
            
            # 设置透明度uniform
            glUniform1f(self.alpha_loc, alpha)
            
            # 计算变换矩阵
            transform = create_transform_matrix(
                tx=0.0, ty=0.0,
                rotation=0.0,
                sx=1.0, sy=1.0
            )
            
            # 设置变换矩阵uniform
            glUniformMatrix4fv(self.transform_loc, 1, GL_FALSE, transform)
            
            # 绑定纹理
            if "texture" in part:
                glBindTexture(GL_TEXTURE_2D, part["texture"].id)
            
            # 绑定VAO
            glBindVertexArray(self.vao)
            
            # 更新顶点数据
            mesh = part.get("mesh", {})
            if mesh:
                vertices = mesh.get("vertices")
                indices = mesh.get("indices")
                
                if vertices is not None and indices is not None:
                    # 更新顶点缓冲
                    glBindBuffer(GL_ARRAY_BUFFER, self.vbo)
                    glBufferData(GL_ARRAY_BUFFER, vertices.nbytes, vertices, GL_DYNAMIC_DRAW)
                    
                    # 更新索引缓冲
                    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.ebo)
                    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, GL_DYNAMIC_DRAW)
                    
                    # 绘制
                    glDrawElements(GL_TRIANGLES, mesh.get("index_count", 0), GL_UNSIGNED_INT, None)
            
            # 解绑VAO
            glBindVertexArray(0)

    def set_quality(self, quality: str):
        """设置渲染质量
        
        Args:
            quality: 质量级别 ("high", "medium", "low")
        """
        self.texture_manager.set_quality(quality)

    def cleanup(self):
        """清理资源"""
        if self.shader_program:
            glDeleteProgram(self.shader_program)
            
        if self.vao:
            glDeleteVertexArrays(1, [self.vao])
            
        if self.vbo:
            glDeleteBuffers(1, [self.vbo])
            
        if self.ebo:
            glDeleteBuffers(1, [self.ebo])
            
        self.texture_manager.clear_cache()
        self.initialized = False 